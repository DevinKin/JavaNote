* Java NIO: Non-blocking Server
** 非阻塞IO管道
   非阻塞IO管道是一组处理非阻塞IO的组件。这包括了非阻塞读和写IO。
   
   一个组件使用 ~Selector~ 来检查何时又要读取的数据。组件读取输入数据并根据输入数据生成对应的输出。输出数据会再次写入通道。

   非阻塞IO管道不需要同时读取和写入数据，某些管道可能只读取数据，某些管道可能只写入数据。

   非阻塞IO管道可能有一个以上的组件来处理输入数据，非阻塞IO管道的长度依赖于管道需要做多少事。

   一个非阻塞IO管道可能同时从多个 ~Channel~ 读取数据。

   下图是简化的控制流程图，组件是通过 ~Selector~ 启动从 ~Channel~ 读取数据。
   [[../images/pipeline01.png]]

** 非阻塞IO管道和阻塞IO管道
   非阻塞和阻塞IO管道之间的最大区别在于如何从底层 ~Channel~ 读取数据。

   IO管道通常从流中读取数据并把数据切片大小相同的数据块。

   [[../images/pipeline02.png]]

   IO管道的 ~MessageReader~ 和 ~MessageWriter~ 实现被简化，不必处理只读取或只写入部分消息的情况，以及必须恢复消息读取和写入的情况。

*** 阻塞IO管道的缺陷
    阻塞IO管道需要为每个拆分成消息的流提供一个单独的线程。因为每个流的IO接口都会阻塞，直到有一些数据从管道读取。

    如果服务器的并发量大，服务器将需要为每个活动进入连接一个线程，占用的内存很大。

** 基本的非阻塞IO管道设计
   一个非阻塞IO管道可以使用单个线程从多个流中读取信息，这需要流可以切换为非阻塞模式。

   从非阻塞模式的流中读取数据可能返回0或多个字节数
   - 如果为返回0，说明没有数据可读
   - 如果是返回大于1，说明有数据可读
     
   为了避免检查读取流时是否返回0字节，我们使用了Java NIO Selector。可以使用选择器注册一个或多个 ~SelectableChannel~ 实例。 

   当在 ~Selector~ 调用 ~select()~ 或 ~selectNow()~ 方法时，它只会提供实际有数据要读取的 ~SelectableChannel~ 实例。
   [[../images/pipeline03.png]]
** 读取部分信息
   当从 ~SelectableChannel~ 读取数据块时，我们并不知道数据块包含少于还是多于一个信息。

   各部分消息可能性如下
   [[../images/pipeline04.png]]

   为了避免混合不同通道实例的消息数据，我们将每个Channel使用一个Message Reader。
   [[../images/pipeline05.png]]
