* Java NIO Buffer
  一个缓冲区实质上是一个可写入数据的内存块，然后可以再次读取。该内存块包含在NIO Buffer对象中，该对象提供了一组可以简单使用内存块的方法。

** Buffer的基本使用方式
   使用 ~Buffer~ 去读写数据通常有四个步骤
   - 写数据到缓冲区
   - 调用 ~buffer.flip()~
   - 从缓冲区中读取数据
   - 调用 ~buffer.clear()~ 或 ~buffer.compact()~
     
   当写数据到缓冲区中，缓冲区会追踪有多少数据被写入。一旦需要从缓冲区读取数据，需要调用 ~flip()~ 方法将缓冲区从写模式切换到读模式。在读模式下，缓冲区允许您读取写入缓冲区的所有数据。

   当你从缓冲区读取完所有的数据，你需要清除缓冲区，以便重新将数据写入缓冲区。可以使用以下两种方式实现
   - 调用 ~clear()~ ， ~clear()~ 方法清理整个缓冲区
   - 调用 ~compact()~ ， ~compact()~ 方法只清理已经被读取的数据。其他没有被读取的数据会挪到缓冲区的开头，并且后面写入的数据会在未读数据之后。
  

** 缓冲区容量，位置和限制
   一个缓冲区有三个常用的属性
   - capacity
   - position
   - limit
   
   ~position~ 和 ~limit~ 的含义依赖于 ~Buffer~ 在读模式还是写模式。 ~capacity~ 含义永远是缓冲区容量，不管缓冲区是什么模式。

   下图是缓冲区三个属性的说明
   [[../images/buffer01.png]]

*** Position
    当写数据到缓冲区，可以在某个位置执行此操作。最初的位置为0，当一个字节、长整数等已写入缓冲区时，位置会被提前指向缓冲区中下一个单元以插入新数据。位置的最大值是 ~capacity-1~

    当从缓冲区读取数据时，可以在给定位置开始读取。当缓冲区调用 ~flip()~ 从写模式切换到读模式时， ~position~ 会被重置为0。当从缓冲区某个位置开始读取数据时， ~position~ 会被提前指向下一个可读的位置。


*** Limit
    在写模式下， ~limit~ 限制了写入到缓冲区的数据的大小，在写模式下缓冲区的 ~limit~ 等于 ~capacity~ 。
    
    当缓冲区从写模式切换到读模式， ~limit~ 的含义是能从缓冲区读取多少的数据

** 缓冲区分配空间
   要获取缓冲区对象首先需要为缓冲区分配空间。分配空间的方法为 ~allocate()~


** 写数据到缓冲区
   将数据写入到缓冲区有两种方式
   - 将数据从Channel中写入缓冲区
   - 使用 ~put()~ 方法字定义写入缓冲区的数据
  

** flip()
   ~flip()~ 将缓冲区从写模式切换为读模式，调用该方法会将 ~position~ 重置为0，将 ~limit~ 设置为 ~position~ 重置前的值。


** 从缓冲区中读取数据
   从缓冲区读取数据有两种方式
   - 将数据从缓冲区读入通道
   - 调用 ~get()~ 方法从缓冲区读取数据
   

** rewind()
   ~Buffer.rewind()~ 方法重置 ~position~ 为0，所以你可以重新读取缓冲区中所有的数据。 ~limit~ 保持不变，因此仍会标记可以从缓冲区中读取多少的元素。


** clear()和compact()
   ~clear()~ 方法会重置 ~position~ 为0并设置 ~limit~ 为 ~capacity~ 。换句话说，缓冲区已经被清除，但是数据并没有清除，只是修改标记以便告诉写入数据到缓冲区的位置。

   ~compact()~ 方法会拷贝从缓冲区开始所有未读的数据，该方法会设置 ~position~ 为最后一个未读元素的右边。 ~limit~ 会被设置为 ~capacity~ 一样的大小。现在可以写写数据到缓冲区了，但不会覆盖未读的数据。


** mark()和reset()
   ~Buffer.mark()~ 方法可以标记缓冲区的给定位置 ~position~ 。

   ~Buffer.reset()~ 方法可以将位置重置为标记位置。
